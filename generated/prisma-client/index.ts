// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  author: (where?: AuthorWhereInput) => Promise<boolean>;
  reviewAssignment: (where?: ReviewAssignmentWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  author: (where: AuthorWhereUniqueInput) => AuthorNullablePromise;
  authors: (args?: {
    where?: AuthorWhereInput;
    orderBy?: AuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Author>;
  authorsConnection: (args?: {
    where?: AuthorWhereInput;
    orderBy?: AuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AuthorConnectionPromise;
  reviewAssignment: (
    where: ReviewAssignmentWhereUniqueInput
  ) => ReviewAssignmentNullablePromise;
  reviewAssignments: (args?: {
    where?: ReviewAssignmentWhereInput;
    orderBy?: ReviewAssignmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ReviewAssignment>;
  reviewAssignmentsConnection: (args?: {
    where?: ReviewAssignmentWhereInput;
    orderBy?: ReviewAssignmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReviewAssignmentConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAuthor: (data: AuthorCreateInput) => AuthorPromise;
  updateAuthor: (args: {
    data: AuthorUpdateInput;
    where: AuthorWhereUniqueInput;
  }) => AuthorPromise;
  updateManyAuthors: (args: {
    data: AuthorUpdateManyMutationInput;
    where?: AuthorWhereInput;
  }) => BatchPayloadPromise;
  upsertAuthor: (args: {
    where: AuthorWhereUniqueInput;
    create: AuthorCreateInput;
    update: AuthorUpdateInput;
  }) => AuthorPromise;
  deleteAuthor: (where: AuthorWhereUniqueInput) => AuthorPromise;
  deleteManyAuthors: (where?: AuthorWhereInput) => BatchPayloadPromise;
  createReviewAssignment: (
    data: ReviewAssignmentCreateInput
  ) => ReviewAssignmentPromise;
  updateReviewAssignment: (args: {
    data: ReviewAssignmentUpdateInput;
    where: ReviewAssignmentWhereUniqueInput;
  }) => ReviewAssignmentPromise;
  updateManyReviewAssignments: (args: {
    data: ReviewAssignmentUpdateManyMutationInput;
    where?: ReviewAssignmentWhereInput;
  }) => BatchPayloadPromise;
  upsertReviewAssignment: (args: {
    where: ReviewAssignmentWhereUniqueInput;
    create: ReviewAssignmentCreateInput;
    update: ReviewAssignmentUpdateInput;
  }) => ReviewAssignmentPromise;
  deleteReviewAssignment: (
    where: ReviewAssignmentWhereUniqueInput
  ) => ReviewAssignmentPromise;
  deleteManyReviewAssignments: (
    where?: ReviewAssignmentWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  author: (
    where?: AuthorSubscriptionWhereInput
  ) => AuthorSubscriptionPayloadSubscription;
  reviewAssignment: (
    where?: ReviewAssignmentSubscriptionWhereInput
  ) => ReviewAssignmentSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AuthorOrderByInput =
  | "author_id_ASC"
  | "author_id_DESC"
  | "country_ASC"
  | "country_DESC"
  | "email_ASC"
  | "email_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "includeInBrowse_ASC"
  | "includeInBrowse_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "middleName_ASC"
  | "middleName_DESC"
  | "primaryContact_ASC"
  | "primaryContact_DESC"
  | "seq_ASC"
  | "seq_DESC"
  | "submissionId_ASC"
  | "submissionId_DESC"
  | "suffix_ASC"
  | "suffix_DESC"
  | "url_ASC"
  | "url_DESC"
  | "userGroupId_ASC"
  | "userGroupId_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ReviewAssignmentOrderByInput =
  | "review_id_ASC"
  | "review_id_DESC"
  | "competingInterests_ASC"
  | "competingInterests_DESC"
  | "dateAcknowledged_ASC"
  | "dateAcknowledged_DESC"
  | "dateAssigned_ASC"
  | "dateAssigned_DESC"
  | "dateCompleted_ASC"
  | "dateCompleted_DESC"
  | "dateConfirmed_ASC"
  | "dateConfirmed_DESC"
  | "dateDue_ASC"
  | "dateDue_DESC"
  | "dateNotified_ASC"
  | "dateNotified_DESC"
  | "dateRated_ASC"
  | "dateRated_DESC"
  | "dateReminded_ASC"
  | "dateReminded_DESC"
  | "dateResponseDue_ASC"
  | "dateResponseDue_DESC"
  | "declined_ASC"
  | "declined_DESC"
  | "lastModified_ASC"
  | "lastModified_DESC"
  | "quality_ASC"
  | "quality_DESC"
  | "recommendation_ASC"
  | "recommendation_DESC"
  | "reminderWasAutomatic_ASC"
  | "reminderWasAutomatic_DESC"
  | "replaced_ASC"
  | "replaced_DESC"
  | "reviewerFileId_ASC"
  | "reviewerFileId_DESC"
  | "reviewerId_ASC"
  | "reviewerId_DESC"
  | "reviewFormId_ASC"
  | "reviewFormId_DESC"
  | "reviewMethod_ASC"
  | "reviewMethod_DESC"
  | "reviewRoundId_ASC"
  | "reviewRoundId_DESC"
  | "round_ASC"
  | "round_DESC"
  | "stageId_ASC"
  | "stageId_DESC"
  | "step_ASC"
  | "step_DESC"
  | "submissionId_ASC"
  | "submissionId_DESC"
  | "unconsidered_ASC"
  | "unconsidered_DESC";

export type UserOrderByInput =
  | "user_id_ASC"
  | "user_id_DESC"
  | "authId_ASC"
  | "authId_DESC"
  | "authStr_ASC"
  | "authStr_DESC"
  | "billingAddress_ASC"
  | "billingAddress_DESC"
  | "country_ASC"
  | "country_DESC"
  | "dateLastEmail_ASC"
  | "dateLastEmail_DESC"
  | "dateLastLogin_ASC"
  | "dateLastLogin_DESC"
  | "dateRegistered_ASC"
  | "dateRegistered_DESC"
  | "dateValidated_ASC"
  | "dateValidated_DESC"
  | "disabled_ASC"
  | "disabled_DESC"
  | "disabledReason_ASC"
  | "disabledReason_DESC"
  | "email_ASC"
  | "email_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "initials_ASC"
  | "initials_DESC"
  | "inlineHelp_ASC"
  | "inlineHelp_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "locales_ASC"
  | "locales_DESC"
  | "mailingAddress_ASC"
  | "mailingAddress_DESC"
  | "middleName_ASC"
  | "middleName_DESC"
  | "mustChangePassword_ASC"
  | "mustChangePassword_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "salutation_ASC"
  | "salutation_DESC"
  | "suffix_ASC"
  | "suffix_DESC"
  | "url_ASC"
  | "url_DESC"
  | "username_ASC"
  | "username_DESC";

export type ReviewAssignmentWhereUniqueInput = AtLeastOne<{
  review_id: Maybe<Int>;
}>;

export interface ReviewAssignmentWhereInput {
  review_id?: Maybe<Int>;
  review_id_not?: Maybe<Int>;
  review_id_in?: Maybe<Int[] | Int>;
  review_id_not_in?: Maybe<Int[] | Int>;
  review_id_lt?: Maybe<Int>;
  review_id_lte?: Maybe<Int>;
  review_id_gt?: Maybe<Int>;
  review_id_gte?: Maybe<Int>;
  competingInterests?: Maybe<String>;
  competingInterests_not?: Maybe<String>;
  competingInterests_in?: Maybe<String[] | String>;
  competingInterests_not_in?: Maybe<String[] | String>;
  competingInterests_lt?: Maybe<String>;
  competingInterests_lte?: Maybe<String>;
  competingInterests_gt?: Maybe<String>;
  competingInterests_gte?: Maybe<String>;
  competingInterests_contains?: Maybe<String>;
  competingInterests_not_contains?: Maybe<String>;
  competingInterests_starts_with?: Maybe<String>;
  competingInterests_not_starts_with?: Maybe<String>;
  competingInterests_ends_with?: Maybe<String>;
  competingInterests_not_ends_with?: Maybe<String>;
  dateAcknowledged?: Maybe<DateTimeInput>;
  dateAcknowledged_not?: Maybe<DateTimeInput>;
  dateAcknowledged_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateAcknowledged_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateAcknowledged_lt?: Maybe<DateTimeInput>;
  dateAcknowledged_lte?: Maybe<DateTimeInput>;
  dateAcknowledged_gt?: Maybe<DateTimeInput>;
  dateAcknowledged_gte?: Maybe<DateTimeInput>;
  dateAssigned?: Maybe<DateTimeInput>;
  dateAssigned_not?: Maybe<DateTimeInput>;
  dateAssigned_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateAssigned_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateAssigned_lt?: Maybe<DateTimeInput>;
  dateAssigned_lte?: Maybe<DateTimeInput>;
  dateAssigned_gt?: Maybe<DateTimeInput>;
  dateAssigned_gte?: Maybe<DateTimeInput>;
  dateCompleted?: Maybe<DateTimeInput>;
  dateCompleted_not?: Maybe<DateTimeInput>;
  dateCompleted_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateCompleted_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateCompleted_lt?: Maybe<DateTimeInput>;
  dateCompleted_lte?: Maybe<DateTimeInput>;
  dateCompleted_gt?: Maybe<DateTimeInput>;
  dateCompleted_gte?: Maybe<DateTimeInput>;
  dateConfirmed?: Maybe<DateTimeInput>;
  dateConfirmed_not?: Maybe<DateTimeInput>;
  dateConfirmed_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateConfirmed_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateConfirmed_lt?: Maybe<DateTimeInput>;
  dateConfirmed_lte?: Maybe<DateTimeInput>;
  dateConfirmed_gt?: Maybe<DateTimeInput>;
  dateConfirmed_gte?: Maybe<DateTimeInput>;
  dateDue?: Maybe<DateTimeInput>;
  dateDue_not?: Maybe<DateTimeInput>;
  dateDue_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateDue_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateDue_lt?: Maybe<DateTimeInput>;
  dateDue_lte?: Maybe<DateTimeInput>;
  dateDue_gt?: Maybe<DateTimeInput>;
  dateDue_gte?: Maybe<DateTimeInput>;
  dateNotified?: Maybe<DateTimeInput>;
  dateNotified_not?: Maybe<DateTimeInput>;
  dateNotified_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateNotified_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateNotified_lt?: Maybe<DateTimeInput>;
  dateNotified_lte?: Maybe<DateTimeInput>;
  dateNotified_gt?: Maybe<DateTimeInput>;
  dateNotified_gte?: Maybe<DateTimeInput>;
  dateRated?: Maybe<DateTimeInput>;
  dateRated_not?: Maybe<DateTimeInput>;
  dateRated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateRated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateRated_lt?: Maybe<DateTimeInput>;
  dateRated_lte?: Maybe<DateTimeInput>;
  dateRated_gt?: Maybe<DateTimeInput>;
  dateRated_gte?: Maybe<DateTimeInput>;
  dateReminded?: Maybe<DateTimeInput>;
  dateReminded_not?: Maybe<DateTimeInput>;
  dateReminded_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateReminded_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateReminded_lt?: Maybe<DateTimeInput>;
  dateReminded_lte?: Maybe<DateTimeInput>;
  dateReminded_gt?: Maybe<DateTimeInput>;
  dateReminded_gte?: Maybe<DateTimeInput>;
  dateResponseDue?: Maybe<DateTimeInput>;
  dateResponseDue_not?: Maybe<DateTimeInput>;
  dateResponseDue_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateResponseDue_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateResponseDue_lt?: Maybe<DateTimeInput>;
  dateResponseDue_lte?: Maybe<DateTimeInput>;
  dateResponseDue_gt?: Maybe<DateTimeInput>;
  dateResponseDue_gte?: Maybe<DateTimeInput>;
  declined?: Maybe<Boolean>;
  declined_not?: Maybe<Boolean>;
  lastModified?: Maybe<DateTimeInput>;
  lastModified_not?: Maybe<DateTimeInput>;
  lastModified_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastModified_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastModified_lt?: Maybe<DateTimeInput>;
  lastModified_lte?: Maybe<DateTimeInput>;
  lastModified_gt?: Maybe<DateTimeInput>;
  lastModified_gte?: Maybe<DateTimeInput>;
  quality?: Maybe<Boolean>;
  quality_not?: Maybe<Boolean>;
  recommendation?: Maybe<Boolean>;
  recommendation_not?: Maybe<Boolean>;
  reminderWasAutomatic?: Maybe<Boolean>;
  reminderWasAutomatic_not?: Maybe<Boolean>;
  replaced?: Maybe<Boolean>;
  replaced_not?: Maybe<Boolean>;
  reviewerFileId?: Maybe<Int>;
  reviewerFileId_not?: Maybe<Int>;
  reviewerFileId_in?: Maybe<Int[] | Int>;
  reviewerFileId_not_in?: Maybe<Int[] | Int>;
  reviewerFileId_lt?: Maybe<Int>;
  reviewerFileId_lte?: Maybe<Int>;
  reviewerFileId_gt?: Maybe<Int>;
  reviewerFileId_gte?: Maybe<Int>;
  reviewerId?: Maybe<Int>;
  reviewerId_not?: Maybe<Int>;
  reviewerId_in?: Maybe<Int[] | Int>;
  reviewerId_not_in?: Maybe<Int[] | Int>;
  reviewerId_lt?: Maybe<Int>;
  reviewerId_lte?: Maybe<Int>;
  reviewerId_gt?: Maybe<Int>;
  reviewerId_gte?: Maybe<Int>;
  reviewFormId?: Maybe<Int>;
  reviewFormId_not?: Maybe<Int>;
  reviewFormId_in?: Maybe<Int[] | Int>;
  reviewFormId_not_in?: Maybe<Int[] | Int>;
  reviewFormId_lt?: Maybe<Int>;
  reviewFormId_lte?: Maybe<Int>;
  reviewFormId_gt?: Maybe<Int>;
  reviewFormId_gte?: Maybe<Int>;
  reviewMethod?: Maybe<Boolean>;
  reviewMethod_not?: Maybe<Boolean>;
  reviewRoundId?: Maybe<Int>;
  reviewRoundId_not?: Maybe<Int>;
  reviewRoundId_in?: Maybe<Int[] | Int>;
  reviewRoundId_not_in?: Maybe<Int[] | Int>;
  reviewRoundId_lt?: Maybe<Int>;
  reviewRoundId_lte?: Maybe<Int>;
  reviewRoundId_gt?: Maybe<Int>;
  reviewRoundId_gte?: Maybe<Int>;
  round?: Maybe<Boolean>;
  round_not?: Maybe<Boolean>;
  stageId?: Maybe<Boolean>;
  stageId_not?: Maybe<Boolean>;
  step?: Maybe<Boolean>;
  step_not?: Maybe<Boolean>;
  submissionId?: Maybe<Int>;
  submissionId_not?: Maybe<Int>;
  submissionId_in?: Maybe<Int[] | Int>;
  submissionId_not_in?: Maybe<Int[] | Int>;
  submissionId_lt?: Maybe<Int>;
  submissionId_lte?: Maybe<Int>;
  submissionId_gt?: Maybe<Int>;
  submissionId_gte?: Maybe<Int>;
  unconsidered?: Maybe<Boolean>;
  unconsidered_not?: Maybe<Boolean>;
  AND?: Maybe<ReviewAssignmentWhereInput[] | ReviewAssignmentWhereInput>;
  OR?: Maybe<ReviewAssignmentWhereInput[] | ReviewAssignmentWhereInput>;
  NOT?: Maybe<ReviewAssignmentWhereInput[] | ReviewAssignmentWhereInput>;
}

export type AuthorWhereUniqueInput = AtLeastOne<{
  author_id: Maybe<Int>;
}>;

export interface ReviewAssignmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReviewAssignmentWhereInput>;
  AND?: Maybe<
    | ReviewAssignmentSubscriptionWhereInput[]
    | ReviewAssignmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ReviewAssignmentSubscriptionWhereInput[]
    | ReviewAssignmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ReviewAssignmentSubscriptionWhereInput[]
    | ReviewAssignmentSubscriptionWhereInput
  >;
}

export interface AuthorWhereInput {
  author_id?: Maybe<Int>;
  author_id_not?: Maybe<Int>;
  author_id_in?: Maybe<Int[] | Int>;
  author_id_not_in?: Maybe<Int[] | Int>;
  author_id_lt?: Maybe<Int>;
  author_id_lte?: Maybe<Int>;
  author_id_gt?: Maybe<Int>;
  author_id_gte?: Maybe<Int>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  includeInBrowse?: Maybe<Boolean>;
  includeInBrowse_not?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  middleName?: Maybe<String>;
  middleName_not?: Maybe<String>;
  middleName_in?: Maybe<String[] | String>;
  middleName_not_in?: Maybe<String[] | String>;
  middleName_lt?: Maybe<String>;
  middleName_lte?: Maybe<String>;
  middleName_gt?: Maybe<String>;
  middleName_gte?: Maybe<String>;
  middleName_contains?: Maybe<String>;
  middleName_not_contains?: Maybe<String>;
  middleName_starts_with?: Maybe<String>;
  middleName_not_starts_with?: Maybe<String>;
  middleName_ends_with?: Maybe<String>;
  middleName_not_ends_with?: Maybe<String>;
  primaryContact?: Maybe<Boolean>;
  primaryContact_not?: Maybe<Boolean>;
  seq?: Maybe<Float>;
  seq_not?: Maybe<Float>;
  seq_in?: Maybe<Float[] | Float>;
  seq_not_in?: Maybe<Float[] | Float>;
  seq_lt?: Maybe<Float>;
  seq_lte?: Maybe<Float>;
  seq_gt?: Maybe<Float>;
  seq_gte?: Maybe<Float>;
  submissionId?: Maybe<Int>;
  submissionId_not?: Maybe<Int>;
  submissionId_in?: Maybe<Int[] | Int>;
  submissionId_not_in?: Maybe<Int[] | Int>;
  submissionId_lt?: Maybe<Int>;
  submissionId_lte?: Maybe<Int>;
  submissionId_gt?: Maybe<Int>;
  submissionId_gte?: Maybe<Int>;
  suffix?: Maybe<String>;
  suffix_not?: Maybe<String>;
  suffix_in?: Maybe<String[] | String>;
  suffix_not_in?: Maybe<String[] | String>;
  suffix_lt?: Maybe<String>;
  suffix_lte?: Maybe<String>;
  suffix_gt?: Maybe<String>;
  suffix_gte?: Maybe<String>;
  suffix_contains?: Maybe<String>;
  suffix_not_contains?: Maybe<String>;
  suffix_starts_with?: Maybe<String>;
  suffix_not_starts_with?: Maybe<String>;
  suffix_ends_with?: Maybe<String>;
  suffix_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  userGroupId?: Maybe<Int>;
  userGroupId_not?: Maybe<Int>;
  userGroupId_in?: Maybe<Int[] | Int>;
  userGroupId_not_in?: Maybe<Int[] | Int>;
  userGroupId_lt?: Maybe<Int>;
  userGroupId_lte?: Maybe<Int>;
  userGroupId_gt?: Maybe<Int>;
  userGroupId_gte?: Maybe<Int>;
  AND?: Maybe<AuthorWhereInput[] | AuthorWhereInput>;
  OR?: Maybe<AuthorWhereInput[] | AuthorWhereInput>;
  NOT?: Maybe<AuthorWhereInput[] | AuthorWhereInput>;
}

export interface AuthorUpdateManyMutationInput {
  country?: Maybe<String>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  includeInBrowse?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  middleName?: Maybe<String>;
  primaryContact?: Maybe<Boolean>;
  seq?: Maybe<Float>;
  submissionId?: Maybe<Int>;
  suffix?: Maybe<String>;
  url?: Maybe<String>;
  userGroupId?: Maybe<Int>;
}

export interface UserUpdateManyMutationInput {
  authId?: Maybe<Int>;
  authStr?: Maybe<String>;
  billingAddress?: Maybe<String>;
  country?: Maybe<String>;
  dateLastEmail?: Maybe<DateTimeInput>;
  dateLastLogin?: Maybe<DateTimeInput>;
  dateRegistered?: Maybe<DateTimeInput>;
  dateValidated?: Maybe<DateTimeInput>;
  disabled?: Maybe<Boolean>;
  disabledReason?: Maybe<String>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  gender?: Maybe<String>;
  initials?: Maybe<String>;
  inlineHelp?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  locales?: Maybe<String>;
  mailingAddress?: Maybe<String>;
  middleName?: Maybe<String>;
  mustChangePassword?: Maybe<Boolean>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  salutation?: Maybe<String>;
  suffix?: Maybe<String>;
  url?: Maybe<String>;
  username?: Maybe<String>;
}

export interface AuthorUpdateInput {
  country?: Maybe<String>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  includeInBrowse?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  middleName?: Maybe<String>;
  primaryContact?: Maybe<Boolean>;
  seq?: Maybe<Float>;
  submissionId?: Maybe<Int>;
  suffix?: Maybe<String>;
  url?: Maybe<String>;
  userGroupId?: Maybe<Int>;
}

export interface UserCreateInput {
  user_id?: Maybe<Int>;
  authId?: Maybe<Int>;
  authStr?: Maybe<String>;
  billingAddress?: Maybe<String>;
  country?: Maybe<String>;
  dateLastEmail?: Maybe<DateTimeInput>;
  dateLastLogin: DateTimeInput;
  dateRegistered: DateTimeInput;
  dateValidated?: Maybe<DateTimeInput>;
  disabled?: Maybe<Boolean>;
  disabledReason?: Maybe<String>;
  email: String;
  firstName: String;
  gender?: Maybe<String>;
  initials?: Maybe<String>;
  inlineHelp?: Maybe<Boolean>;
  lastName: String;
  locales?: Maybe<String>;
  mailingAddress?: Maybe<String>;
  middleName?: Maybe<String>;
  mustChangePassword?: Maybe<Boolean>;
  password: String;
  phone?: Maybe<String>;
  salutation?: Maybe<String>;
  suffix?: Maybe<String>;
  url?: Maybe<String>;
  username: String;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserWhereInput {
  user_id?: Maybe<Int>;
  user_id_not?: Maybe<Int>;
  user_id_in?: Maybe<Int[] | Int>;
  user_id_not_in?: Maybe<Int[] | Int>;
  user_id_lt?: Maybe<Int>;
  user_id_lte?: Maybe<Int>;
  user_id_gt?: Maybe<Int>;
  user_id_gte?: Maybe<Int>;
  authId?: Maybe<Int>;
  authId_not?: Maybe<Int>;
  authId_in?: Maybe<Int[] | Int>;
  authId_not_in?: Maybe<Int[] | Int>;
  authId_lt?: Maybe<Int>;
  authId_lte?: Maybe<Int>;
  authId_gt?: Maybe<Int>;
  authId_gte?: Maybe<Int>;
  authStr?: Maybe<String>;
  authStr_not?: Maybe<String>;
  authStr_in?: Maybe<String[] | String>;
  authStr_not_in?: Maybe<String[] | String>;
  authStr_lt?: Maybe<String>;
  authStr_lte?: Maybe<String>;
  authStr_gt?: Maybe<String>;
  authStr_gte?: Maybe<String>;
  authStr_contains?: Maybe<String>;
  authStr_not_contains?: Maybe<String>;
  authStr_starts_with?: Maybe<String>;
  authStr_not_starts_with?: Maybe<String>;
  authStr_ends_with?: Maybe<String>;
  authStr_not_ends_with?: Maybe<String>;
  billingAddress?: Maybe<String>;
  billingAddress_not?: Maybe<String>;
  billingAddress_in?: Maybe<String[] | String>;
  billingAddress_not_in?: Maybe<String[] | String>;
  billingAddress_lt?: Maybe<String>;
  billingAddress_lte?: Maybe<String>;
  billingAddress_gt?: Maybe<String>;
  billingAddress_gte?: Maybe<String>;
  billingAddress_contains?: Maybe<String>;
  billingAddress_not_contains?: Maybe<String>;
  billingAddress_starts_with?: Maybe<String>;
  billingAddress_not_starts_with?: Maybe<String>;
  billingAddress_ends_with?: Maybe<String>;
  billingAddress_not_ends_with?: Maybe<String>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  dateLastEmail?: Maybe<DateTimeInput>;
  dateLastEmail_not?: Maybe<DateTimeInput>;
  dateLastEmail_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateLastEmail_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateLastEmail_lt?: Maybe<DateTimeInput>;
  dateLastEmail_lte?: Maybe<DateTimeInput>;
  dateLastEmail_gt?: Maybe<DateTimeInput>;
  dateLastEmail_gte?: Maybe<DateTimeInput>;
  dateLastLogin?: Maybe<DateTimeInput>;
  dateLastLogin_not?: Maybe<DateTimeInput>;
  dateLastLogin_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateLastLogin_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateLastLogin_lt?: Maybe<DateTimeInput>;
  dateLastLogin_lte?: Maybe<DateTimeInput>;
  dateLastLogin_gt?: Maybe<DateTimeInput>;
  dateLastLogin_gte?: Maybe<DateTimeInput>;
  dateRegistered?: Maybe<DateTimeInput>;
  dateRegistered_not?: Maybe<DateTimeInput>;
  dateRegistered_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateRegistered_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateRegistered_lt?: Maybe<DateTimeInput>;
  dateRegistered_lte?: Maybe<DateTimeInput>;
  dateRegistered_gt?: Maybe<DateTimeInput>;
  dateRegistered_gte?: Maybe<DateTimeInput>;
  dateValidated?: Maybe<DateTimeInput>;
  dateValidated_not?: Maybe<DateTimeInput>;
  dateValidated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateValidated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dateValidated_lt?: Maybe<DateTimeInput>;
  dateValidated_lte?: Maybe<DateTimeInput>;
  dateValidated_gt?: Maybe<DateTimeInput>;
  dateValidated_gte?: Maybe<DateTimeInput>;
  disabled?: Maybe<Boolean>;
  disabled_not?: Maybe<Boolean>;
  disabledReason?: Maybe<String>;
  disabledReason_not?: Maybe<String>;
  disabledReason_in?: Maybe<String[] | String>;
  disabledReason_not_in?: Maybe<String[] | String>;
  disabledReason_lt?: Maybe<String>;
  disabledReason_lte?: Maybe<String>;
  disabledReason_gt?: Maybe<String>;
  disabledReason_gte?: Maybe<String>;
  disabledReason_contains?: Maybe<String>;
  disabledReason_not_contains?: Maybe<String>;
  disabledReason_starts_with?: Maybe<String>;
  disabledReason_not_starts_with?: Maybe<String>;
  disabledReason_ends_with?: Maybe<String>;
  disabledReason_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  gender?: Maybe<String>;
  gender_not?: Maybe<String>;
  gender_in?: Maybe<String[] | String>;
  gender_not_in?: Maybe<String[] | String>;
  gender_lt?: Maybe<String>;
  gender_lte?: Maybe<String>;
  gender_gt?: Maybe<String>;
  gender_gte?: Maybe<String>;
  gender_contains?: Maybe<String>;
  gender_not_contains?: Maybe<String>;
  gender_starts_with?: Maybe<String>;
  gender_not_starts_with?: Maybe<String>;
  gender_ends_with?: Maybe<String>;
  gender_not_ends_with?: Maybe<String>;
  initials?: Maybe<String>;
  initials_not?: Maybe<String>;
  initials_in?: Maybe<String[] | String>;
  initials_not_in?: Maybe<String[] | String>;
  initials_lt?: Maybe<String>;
  initials_lte?: Maybe<String>;
  initials_gt?: Maybe<String>;
  initials_gte?: Maybe<String>;
  initials_contains?: Maybe<String>;
  initials_not_contains?: Maybe<String>;
  initials_starts_with?: Maybe<String>;
  initials_not_starts_with?: Maybe<String>;
  initials_ends_with?: Maybe<String>;
  initials_not_ends_with?: Maybe<String>;
  inlineHelp?: Maybe<Boolean>;
  inlineHelp_not?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  locales?: Maybe<String>;
  locales_not?: Maybe<String>;
  locales_in?: Maybe<String[] | String>;
  locales_not_in?: Maybe<String[] | String>;
  locales_lt?: Maybe<String>;
  locales_lte?: Maybe<String>;
  locales_gt?: Maybe<String>;
  locales_gte?: Maybe<String>;
  locales_contains?: Maybe<String>;
  locales_not_contains?: Maybe<String>;
  locales_starts_with?: Maybe<String>;
  locales_not_starts_with?: Maybe<String>;
  locales_ends_with?: Maybe<String>;
  locales_not_ends_with?: Maybe<String>;
  mailingAddress?: Maybe<String>;
  mailingAddress_not?: Maybe<String>;
  mailingAddress_in?: Maybe<String[] | String>;
  mailingAddress_not_in?: Maybe<String[] | String>;
  mailingAddress_lt?: Maybe<String>;
  mailingAddress_lte?: Maybe<String>;
  mailingAddress_gt?: Maybe<String>;
  mailingAddress_gte?: Maybe<String>;
  mailingAddress_contains?: Maybe<String>;
  mailingAddress_not_contains?: Maybe<String>;
  mailingAddress_starts_with?: Maybe<String>;
  mailingAddress_not_starts_with?: Maybe<String>;
  mailingAddress_ends_with?: Maybe<String>;
  mailingAddress_not_ends_with?: Maybe<String>;
  middleName?: Maybe<String>;
  middleName_not?: Maybe<String>;
  middleName_in?: Maybe<String[] | String>;
  middleName_not_in?: Maybe<String[] | String>;
  middleName_lt?: Maybe<String>;
  middleName_lte?: Maybe<String>;
  middleName_gt?: Maybe<String>;
  middleName_gte?: Maybe<String>;
  middleName_contains?: Maybe<String>;
  middleName_not_contains?: Maybe<String>;
  middleName_starts_with?: Maybe<String>;
  middleName_not_starts_with?: Maybe<String>;
  middleName_ends_with?: Maybe<String>;
  middleName_not_ends_with?: Maybe<String>;
  mustChangePassword?: Maybe<Boolean>;
  mustChangePassword_not?: Maybe<Boolean>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  salutation?: Maybe<String>;
  salutation_not?: Maybe<String>;
  salutation_in?: Maybe<String[] | String>;
  salutation_not_in?: Maybe<String[] | String>;
  salutation_lt?: Maybe<String>;
  salutation_lte?: Maybe<String>;
  salutation_gt?: Maybe<String>;
  salutation_gte?: Maybe<String>;
  salutation_contains?: Maybe<String>;
  salutation_not_contains?: Maybe<String>;
  salutation_starts_with?: Maybe<String>;
  salutation_not_starts_with?: Maybe<String>;
  salutation_ends_with?: Maybe<String>;
  salutation_not_ends_with?: Maybe<String>;
  suffix?: Maybe<String>;
  suffix_not?: Maybe<String>;
  suffix_in?: Maybe<String[] | String>;
  suffix_not_in?: Maybe<String[] | String>;
  suffix_lt?: Maybe<String>;
  suffix_lte?: Maybe<String>;
  suffix_gt?: Maybe<String>;
  suffix_gte?: Maybe<String>;
  suffix_contains?: Maybe<String>;
  suffix_not_contains?: Maybe<String>;
  suffix_starts_with?: Maybe<String>;
  suffix_not_starts_with?: Maybe<String>;
  suffix_ends_with?: Maybe<String>;
  suffix_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  user_id: Maybe<Int>;
  email?: Maybe<String>;
  username?: Maybe<String>;
}>;

export interface AuthorCreateInput {
  author_id?: Maybe<Int>;
  country?: Maybe<String>;
  email: String;
  firstName: String;
  includeInBrowse?: Maybe<Boolean>;
  lastName: String;
  middleName?: Maybe<String>;
  primaryContact?: Maybe<Boolean>;
  seq?: Maybe<Float>;
  submissionId: Int;
  suffix?: Maybe<String>;
  url?: Maybe<String>;
  userGroupId?: Maybe<Int>;
}

export interface ReviewAssignmentUpdateInput {
  competingInterests?: Maybe<String>;
  dateAcknowledged?: Maybe<DateTimeInput>;
  dateAssigned?: Maybe<DateTimeInput>;
  dateCompleted?: Maybe<DateTimeInput>;
  dateConfirmed?: Maybe<DateTimeInput>;
  dateDue?: Maybe<DateTimeInput>;
  dateNotified?: Maybe<DateTimeInput>;
  dateRated?: Maybe<DateTimeInput>;
  dateReminded?: Maybe<DateTimeInput>;
  dateResponseDue?: Maybe<DateTimeInput>;
  declined?: Maybe<Boolean>;
  lastModified?: Maybe<DateTimeInput>;
  quality?: Maybe<Boolean>;
  recommendation?: Maybe<Boolean>;
  reminderWasAutomatic?: Maybe<Boolean>;
  replaced?: Maybe<Boolean>;
  reviewerFileId?: Maybe<Int>;
  reviewerId?: Maybe<Int>;
  reviewFormId?: Maybe<Int>;
  reviewMethod?: Maybe<Boolean>;
  reviewRoundId?: Maybe<Int>;
  round?: Maybe<Boolean>;
  stageId?: Maybe<Boolean>;
  step?: Maybe<Boolean>;
  submissionId?: Maybe<Int>;
  unconsidered?: Maybe<Boolean>;
}

export interface ReviewAssignmentUpdateManyMutationInput {
  competingInterests?: Maybe<String>;
  dateAcknowledged?: Maybe<DateTimeInput>;
  dateAssigned?: Maybe<DateTimeInput>;
  dateCompleted?: Maybe<DateTimeInput>;
  dateConfirmed?: Maybe<DateTimeInput>;
  dateDue?: Maybe<DateTimeInput>;
  dateNotified?: Maybe<DateTimeInput>;
  dateRated?: Maybe<DateTimeInput>;
  dateReminded?: Maybe<DateTimeInput>;
  dateResponseDue?: Maybe<DateTimeInput>;
  declined?: Maybe<Boolean>;
  lastModified?: Maybe<DateTimeInput>;
  quality?: Maybe<Boolean>;
  recommendation?: Maybe<Boolean>;
  reminderWasAutomatic?: Maybe<Boolean>;
  replaced?: Maybe<Boolean>;
  reviewerFileId?: Maybe<Int>;
  reviewerId?: Maybe<Int>;
  reviewFormId?: Maybe<Int>;
  reviewMethod?: Maybe<Boolean>;
  reviewRoundId?: Maybe<Int>;
  round?: Maybe<Boolean>;
  stageId?: Maybe<Boolean>;
  step?: Maybe<Boolean>;
  submissionId?: Maybe<Int>;
  unconsidered?: Maybe<Boolean>;
}

export interface UserUpdateInput {
  authId?: Maybe<Int>;
  authStr?: Maybe<String>;
  billingAddress?: Maybe<String>;
  country?: Maybe<String>;
  dateLastEmail?: Maybe<DateTimeInput>;
  dateLastLogin?: Maybe<DateTimeInput>;
  dateRegistered?: Maybe<DateTimeInput>;
  dateValidated?: Maybe<DateTimeInput>;
  disabled?: Maybe<Boolean>;
  disabledReason?: Maybe<String>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  gender?: Maybe<String>;
  initials?: Maybe<String>;
  inlineHelp?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  locales?: Maybe<String>;
  mailingAddress?: Maybe<String>;
  middleName?: Maybe<String>;
  mustChangePassword?: Maybe<Boolean>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  salutation?: Maybe<String>;
  suffix?: Maybe<String>;
  url?: Maybe<String>;
  username?: Maybe<String>;
}

export interface AuthorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AuthorWhereInput>;
  AND?: Maybe<AuthorSubscriptionWhereInput[] | AuthorSubscriptionWhereInput>;
  OR?: Maybe<AuthorSubscriptionWhereInput[] | AuthorSubscriptionWhereInput>;
  NOT?: Maybe<AuthorSubscriptionWhereInput[] | AuthorSubscriptionWhereInput>;
}

export interface ReviewAssignmentCreateInput {
  review_id?: Maybe<Int>;
  competingInterests?: Maybe<String>;
  dateAcknowledged?: Maybe<DateTimeInput>;
  dateAssigned?: Maybe<DateTimeInput>;
  dateCompleted?: Maybe<DateTimeInput>;
  dateConfirmed?: Maybe<DateTimeInput>;
  dateDue?: Maybe<DateTimeInput>;
  dateNotified?: Maybe<DateTimeInput>;
  dateRated?: Maybe<DateTimeInput>;
  dateReminded?: Maybe<DateTimeInput>;
  dateResponseDue?: Maybe<DateTimeInput>;
  declined?: Maybe<Boolean>;
  lastModified?: Maybe<DateTimeInput>;
  quality?: Maybe<Boolean>;
  recommendation?: Maybe<Boolean>;
  reminderWasAutomatic?: Maybe<Boolean>;
  replaced?: Maybe<Boolean>;
  reviewerFileId?: Maybe<Int>;
  reviewerId: Int;
  reviewFormId?: Maybe<Int>;
  reviewMethod?: Maybe<Boolean>;
  reviewRoundId?: Maybe<Int>;
  round?: Maybe<Boolean>;
  stageId?: Maybe<Boolean>;
  step?: Maybe<Boolean>;
  submissionId: Int;
  unconsidered?: Maybe<Boolean>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AuthorEdge {
  node: Author;
  cursor: String;
}

export interface AuthorEdgePromise extends Promise<AuthorEdge>, Fragmentable {
  node: <T = AuthorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AuthorEdgeSubscription
  extends Promise<AsyncIterator<AuthorEdge>>,
    Fragmentable {
  node: <T = AuthorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserPreviousValues {
  user_id: Int;
  authId?: Int;
  authStr?: String;
  billingAddress?: String;
  country?: String;
  dateLastEmail?: DateTimeOutput;
  dateLastLogin: DateTimeOutput;
  dateRegistered: DateTimeOutput;
  dateValidated?: DateTimeOutput;
  disabled: Boolean;
  disabledReason?: String;
  email: String;
  firstName: String;
  gender?: String;
  initials?: String;
  inlineHelp?: Boolean;
  lastName: String;
  locales?: String;
  mailingAddress?: String;
  middleName?: String;
  mustChangePassword?: Boolean;
  password: String;
  phone?: String;
  salutation?: String;
  suffix?: String;
  url?: String;
  username: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  user_id: () => Promise<Int>;
  authId: () => Promise<Int>;
  authStr: () => Promise<String>;
  billingAddress: () => Promise<String>;
  country: () => Promise<String>;
  dateLastEmail: () => Promise<DateTimeOutput>;
  dateLastLogin: () => Promise<DateTimeOutput>;
  dateRegistered: () => Promise<DateTimeOutput>;
  dateValidated: () => Promise<DateTimeOutput>;
  disabled: () => Promise<Boolean>;
  disabledReason: () => Promise<String>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  gender: () => Promise<String>;
  initials: () => Promise<String>;
  inlineHelp: () => Promise<Boolean>;
  lastName: () => Promise<String>;
  locales: () => Promise<String>;
  mailingAddress: () => Promise<String>;
  middleName: () => Promise<String>;
  mustChangePassword: () => Promise<Boolean>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  salutation: () => Promise<String>;
  suffix: () => Promise<String>;
  url: () => Promise<String>;
  username: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  user_id: () => Promise<AsyncIterator<Int>>;
  authId: () => Promise<AsyncIterator<Int>>;
  authStr: () => Promise<AsyncIterator<String>>;
  billingAddress: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  dateLastEmail: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateLastLogin: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateRegistered: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateValidated: () => Promise<AsyncIterator<DateTimeOutput>>;
  disabled: () => Promise<AsyncIterator<Boolean>>;
  disabledReason: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  initials: () => Promise<AsyncIterator<String>>;
  inlineHelp: () => Promise<AsyncIterator<Boolean>>;
  lastName: () => Promise<AsyncIterator<String>>;
  locales: () => Promise<AsyncIterator<String>>;
  mailingAddress: () => Promise<AsyncIterator<String>>;
  middleName: () => Promise<AsyncIterator<String>>;
  mustChangePassword: () => Promise<AsyncIterator<Boolean>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  salutation: () => Promise<AsyncIterator<String>>;
  suffix: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AuthorConnection {
  pageInfo: PageInfo;
  edges: AuthorEdge[];
}

export interface AuthorConnectionPromise
  extends Promise<AuthorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AuthorEdge>>() => T;
  aggregate: <T = AggregateAuthorPromise>() => T;
}

export interface AuthorConnectionSubscription
  extends Promise<AsyncIterator<AuthorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AuthorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAuthorSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  user_id: Int;
  authId?: Int;
  authStr?: String;
  billingAddress?: String;
  country?: String;
  dateLastEmail?: DateTimeOutput;
  dateLastLogin: DateTimeOutput;
  dateRegistered: DateTimeOutput;
  dateValidated?: DateTimeOutput;
  disabled: Boolean;
  disabledReason?: String;
  email: String;
  firstName: String;
  gender?: String;
  initials?: String;
  inlineHelp?: Boolean;
  lastName: String;
  locales?: String;
  mailingAddress?: String;
  middleName?: String;
  mustChangePassword?: Boolean;
  password: String;
  phone?: String;
  salutation?: String;
  suffix?: String;
  url?: String;
  username: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  user_id: () => Promise<Int>;
  authId: () => Promise<Int>;
  authStr: () => Promise<String>;
  billingAddress: () => Promise<String>;
  country: () => Promise<String>;
  dateLastEmail: () => Promise<DateTimeOutput>;
  dateLastLogin: () => Promise<DateTimeOutput>;
  dateRegistered: () => Promise<DateTimeOutput>;
  dateValidated: () => Promise<DateTimeOutput>;
  disabled: () => Promise<Boolean>;
  disabledReason: () => Promise<String>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  gender: () => Promise<String>;
  initials: () => Promise<String>;
  inlineHelp: () => Promise<Boolean>;
  lastName: () => Promise<String>;
  locales: () => Promise<String>;
  mailingAddress: () => Promise<String>;
  middleName: () => Promise<String>;
  mustChangePassword: () => Promise<Boolean>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  salutation: () => Promise<String>;
  suffix: () => Promise<String>;
  url: () => Promise<String>;
  username: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  user_id: () => Promise<AsyncIterator<Int>>;
  authId: () => Promise<AsyncIterator<Int>>;
  authStr: () => Promise<AsyncIterator<String>>;
  billingAddress: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  dateLastEmail: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateLastLogin: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateRegistered: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateValidated: () => Promise<AsyncIterator<DateTimeOutput>>;
  disabled: () => Promise<AsyncIterator<Boolean>>;
  disabledReason: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  initials: () => Promise<AsyncIterator<String>>;
  inlineHelp: () => Promise<AsyncIterator<Boolean>>;
  lastName: () => Promise<AsyncIterator<String>>;
  locales: () => Promise<AsyncIterator<String>>;
  mailingAddress: () => Promise<AsyncIterator<String>>;
  middleName: () => Promise<AsyncIterator<String>>;
  mustChangePassword: () => Promise<AsyncIterator<Boolean>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  salutation: () => Promise<AsyncIterator<String>>;
  suffix: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  user_id: () => Promise<Int>;
  authId: () => Promise<Int>;
  authStr: () => Promise<String>;
  billingAddress: () => Promise<String>;
  country: () => Promise<String>;
  dateLastEmail: () => Promise<DateTimeOutput>;
  dateLastLogin: () => Promise<DateTimeOutput>;
  dateRegistered: () => Promise<DateTimeOutput>;
  dateValidated: () => Promise<DateTimeOutput>;
  disabled: () => Promise<Boolean>;
  disabledReason: () => Promise<String>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  gender: () => Promise<String>;
  initials: () => Promise<String>;
  inlineHelp: () => Promise<Boolean>;
  lastName: () => Promise<String>;
  locales: () => Promise<String>;
  mailingAddress: () => Promise<String>;
  middleName: () => Promise<String>;
  mustChangePassword: () => Promise<Boolean>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  salutation: () => Promise<String>;
  suffix: () => Promise<String>;
  url: () => Promise<String>;
  username: () => Promise<String>;
}

export interface ReviewAssignmentEdge {
  node: ReviewAssignment;
  cursor: String;
}

export interface ReviewAssignmentEdgePromise
  extends Promise<ReviewAssignmentEdge>,
    Fragmentable {
  node: <T = ReviewAssignmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReviewAssignmentEdgeSubscription
  extends Promise<AsyncIterator<ReviewAssignmentEdge>>,
    Fragmentable {
  node: <T = ReviewAssignmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ReviewAssignmentPreviousValues {
  review_id: Int;
  competingInterests?: String;
  dateAcknowledged?: DateTimeOutput;
  dateAssigned?: DateTimeOutput;
  dateCompleted?: DateTimeOutput;
  dateConfirmed?: DateTimeOutput;
  dateDue?: DateTimeOutput;
  dateNotified?: DateTimeOutput;
  dateRated?: DateTimeOutput;
  dateReminded?: DateTimeOutput;
  dateResponseDue?: DateTimeOutput;
  declined: Boolean;
  lastModified?: DateTimeOutput;
  quality?: Boolean;
  recommendation?: Boolean;
  reminderWasAutomatic: Boolean;
  replaced: Boolean;
  reviewerFileId?: Int;
  reviewerId: Int;
  reviewFormId?: Int;
  reviewMethod: Boolean;
  reviewRoundId?: Int;
  round: Boolean;
  stageId: Boolean;
  step: Boolean;
  submissionId: Int;
  unconsidered?: Boolean;
}

export interface ReviewAssignmentPreviousValuesPromise
  extends Promise<ReviewAssignmentPreviousValues>,
    Fragmentable {
  review_id: () => Promise<Int>;
  competingInterests: () => Promise<String>;
  dateAcknowledged: () => Promise<DateTimeOutput>;
  dateAssigned: () => Promise<DateTimeOutput>;
  dateCompleted: () => Promise<DateTimeOutput>;
  dateConfirmed: () => Promise<DateTimeOutput>;
  dateDue: () => Promise<DateTimeOutput>;
  dateNotified: () => Promise<DateTimeOutput>;
  dateRated: () => Promise<DateTimeOutput>;
  dateReminded: () => Promise<DateTimeOutput>;
  dateResponseDue: () => Promise<DateTimeOutput>;
  declined: () => Promise<Boolean>;
  lastModified: () => Promise<DateTimeOutput>;
  quality: () => Promise<Boolean>;
  recommendation: () => Promise<Boolean>;
  reminderWasAutomatic: () => Promise<Boolean>;
  replaced: () => Promise<Boolean>;
  reviewerFileId: () => Promise<Int>;
  reviewerId: () => Promise<Int>;
  reviewFormId: () => Promise<Int>;
  reviewMethod: () => Promise<Boolean>;
  reviewRoundId: () => Promise<Int>;
  round: () => Promise<Boolean>;
  stageId: () => Promise<Boolean>;
  step: () => Promise<Boolean>;
  submissionId: () => Promise<Int>;
  unconsidered: () => Promise<Boolean>;
}

export interface ReviewAssignmentPreviousValuesSubscription
  extends Promise<AsyncIterator<ReviewAssignmentPreviousValues>>,
    Fragmentable {
  review_id: () => Promise<AsyncIterator<Int>>;
  competingInterests: () => Promise<AsyncIterator<String>>;
  dateAcknowledged: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateAssigned: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateCompleted: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateConfirmed: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateDue: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateNotified: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateRated: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateReminded: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateResponseDue: () => Promise<AsyncIterator<DateTimeOutput>>;
  declined: () => Promise<AsyncIterator<Boolean>>;
  lastModified: () => Promise<AsyncIterator<DateTimeOutput>>;
  quality: () => Promise<AsyncIterator<Boolean>>;
  recommendation: () => Promise<AsyncIterator<Boolean>>;
  reminderWasAutomatic: () => Promise<AsyncIterator<Boolean>>;
  replaced: () => Promise<AsyncIterator<Boolean>>;
  reviewerFileId: () => Promise<AsyncIterator<Int>>;
  reviewerId: () => Promise<AsyncIterator<Int>>;
  reviewFormId: () => Promise<AsyncIterator<Int>>;
  reviewMethod: () => Promise<AsyncIterator<Boolean>>;
  reviewRoundId: () => Promise<AsyncIterator<Int>>;
  round: () => Promise<AsyncIterator<Boolean>>;
  stageId: () => Promise<AsyncIterator<Boolean>>;
  step: () => Promise<AsyncIterator<Boolean>>;
  submissionId: () => Promise<AsyncIterator<Int>>;
  unconsidered: () => Promise<AsyncIterator<Boolean>>;
}

export interface AuthorPreviousValues {
  author_id: Int;
  country?: String;
  email: String;
  firstName: String;
  includeInBrowse: Boolean;
  lastName: String;
  middleName?: String;
  primaryContact: Boolean;
  seq: Float;
  submissionId: Int;
  suffix?: String;
  url?: String;
  userGroupId?: Int;
}

export interface AuthorPreviousValuesPromise
  extends Promise<AuthorPreviousValues>,
    Fragmentable {
  author_id: () => Promise<Int>;
  country: () => Promise<String>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  includeInBrowse: () => Promise<Boolean>;
  lastName: () => Promise<String>;
  middleName: () => Promise<String>;
  primaryContact: () => Promise<Boolean>;
  seq: () => Promise<Float>;
  submissionId: () => Promise<Int>;
  suffix: () => Promise<String>;
  url: () => Promise<String>;
  userGroupId: () => Promise<Int>;
}

export interface AuthorPreviousValuesSubscription
  extends Promise<AsyncIterator<AuthorPreviousValues>>,
    Fragmentable {
  author_id: () => Promise<AsyncIterator<Int>>;
  country: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  includeInBrowse: () => Promise<AsyncIterator<Boolean>>;
  lastName: () => Promise<AsyncIterator<String>>;
  middleName: () => Promise<AsyncIterator<String>>;
  primaryContact: () => Promise<AsyncIterator<Boolean>>;
  seq: () => Promise<AsyncIterator<Float>>;
  submissionId: () => Promise<AsyncIterator<Int>>;
  suffix: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  userGroupId: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AuthorSubscriptionPayload {
  mutation: MutationType;
  node: Author;
  updatedFields: String[];
  previousValues: AuthorPreviousValues;
}

export interface AuthorSubscriptionPayloadPromise
  extends Promise<AuthorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AuthorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AuthorPreviousValuesPromise>() => T;
}

export interface AuthorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AuthorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AuthorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AuthorPreviousValuesSubscription>() => T;
}

export interface ReviewAssignmentSubscriptionPayload {
  mutation: MutationType;
  node: ReviewAssignment;
  updatedFields: String[];
  previousValues: ReviewAssignmentPreviousValues;
}

export interface ReviewAssignmentSubscriptionPayloadPromise
  extends Promise<ReviewAssignmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReviewAssignmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReviewAssignmentPreviousValuesPromise>() => T;
}

export interface ReviewAssignmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReviewAssignmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReviewAssignmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReviewAssignmentPreviousValuesSubscription>() => T;
}

export interface ReviewAssignmentConnection {
  pageInfo: PageInfo;
  edges: ReviewAssignmentEdge[];
}

export interface ReviewAssignmentConnectionPromise
  extends Promise<ReviewAssignmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReviewAssignmentEdge>>() => T;
  aggregate: <T = AggregateReviewAssignmentPromise>() => T;
}

export interface ReviewAssignmentConnectionSubscription
  extends Promise<AsyncIterator<ReviewAssignmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReviewAssignmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReviewAssignmentSubscription>() => T;
}

export interface AggregateReviewAssignment {
  count: Int;
}

export interface AggregateReviewAssignmentPromise
  extends Promise<AggregateReviewAssignment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReviewAssignmentSubscription
  extends Promise<AsyncIterator<AggregateReviewAssignment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface Author {
  author_id: Int;
  country?: String;
  email: String;
  firstName: String;
  includeInBrowse: Boolean;
  lastName: String;
  middleName?: String;
  primaryContact: Boolean;
  seq: Float;
  submissionId: Int;
  suffix?: String;
  url?: String;
  userGroupId?: Int;
}

export interface AuthorPromise extends Promise<Author>, Fragmentable {
  author_id: () => Promise<Int>;
  country: () => Promise<String>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  includeInBrowse: () => Promise<Boolean>;
  lastName: () => Promise<String>;
  middleName: () => Promise<String>;
  primaryContact: () => Promise<Boolean>;
  seq: () => Promise<Float>;
  submissionId: () => Promise<Int>;
  suffix: () => Promise<String>;
  url: () => Promise<String>;
  userGroupId: () => Promise<Int>;
}

export interface AuthorSubscription
  extends Promise<AsyncIterator<Author>>,
    Fragmentable {
  author_id: () => Promise<AsyncIterator<Int>>;
  country: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  includeInBrowse: () => Promise<AsyncIterator<Boolean>>;
  lastName: () => Promise<AsyncIterator<String>>;
  middleName: () => Promise<AsyncIterator<String>>;
  primaryContact: () => Promise<AsyncIterator<Boolean>>;
  seq: () => Promise<AsyncIterator<Float>>;
  submissionId: () => Promise<AsyncIterator<Int>>;
  suffix: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  userGroupId: () => Promise<AsyncIterator<Int>>;
}

export interface AuthorNullablePromise
  extends Promise<Author | null>,
    Fragmentable {
  author_id: () => Promise<Int>;
  country: () => Promise<String>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  includeInBrowse: () => Promise<Boolean>;
  lastName: () => Promise<String>;
  middleName: () => Promise<String>;
  primaryContact: () => Promise<Boolean>;
  seq: () => Promise<Float>;
  submissionId: () => Promise<Int>;
  suffix: () => Promise<String>;
  url: () => Promise<String>;
  userGroupId: () => Promise<Int>;
}

export interface AggregateAuthor {
  count: Int;
}

export interface AggregateAuthorPromise
  extends Promise<AggregateAuthor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAuthorSubscription
  extends Promise<AsyncIterator<AggregateAuthor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReviewAssignment {
  review_id: Int;
  competingInterests?: String;
  dateAcknowledged?: DateTimeOutput;
  dateAssigned?: DateTimeOutput;
  dateCompleted?: DateTimeOutput;
  dateConfirmed?: DateTimeOutput;
  dateDue?: DateTimeOutput;
  dateNotified?: DateTimeOutput;
  dateRated?: DateTimeOutput;
  dateReminded?: DateTimeOutput;
  dateResponseDue?: DateTimeOutput;
  declined: Boolean;
  lastModified?: DateTimeOutput;
  quality?: Boolean;
  recommendation?: Boolean;
  reminderWasAutomatic: Boolean;
  replaced: Boolean;
  reviewerFileId?: Int;
  reviewerId: Int;
  reviewFormId?: Int;
  reviewMethod: Boolean;
  reviewRoundId?: Int;
  round: Boolean;
  stageId: Boolean;
  step: Boolean;
  submissionId: Int;
  unconsidered?: Boolean;
}

export interface ReviewAssignmentPromise
  extends Promise<ReviewAssignment>,
    Fragmentable {
  review_id: () => Promise<Int>;
  competingInterests: () => Promise<String>;
  dateAcknowledged: () => Promise<DateTimeOutput>;
  dateAssigned: () => Promise<DateTimeOutput>;
  dateCompleted: () => Promise<DateTimeOutput>;
  dateConfirmed: () => Promise<DateTimeOutput>;
  dateDue: () => Promise<DateTimeOutput>;
  dateNotified: () => Promise<DateTimeOutput>;
  dateRated: () => Promise<DateTimeOutput>;
  dateReminded: () => Promise<DateTimeOutput>;
  dateResponseDue: () => Promise<DateTimeOutput>;
  declined: () => Promise<Boolean>;
  lastModified: () => Promise<DateTimeOutput>;
  quality: () => Promise<Boolean>;
  recommendation: () => Promise<Boolean>;
  reminderWasAutomatic: () => Promise<Boolean>;
  replaced: () => Promise<Boolean>;
  reviewerFileId: () => Promise<Int>;
  reviewerId: () => Promise<Int>;
  reviewFormId: () => Promise<Int>;
  reviewMethod: () => Promise<Boolean>;
  reviewRoundId: () => Promise<Int>;
  round: () => Promise<Boolean>;
  stageId: () => Promise<Boolean>;
  step: () => Promise<Boolean>;
  submissionId: () => Promise<Int>;
  unconsidered: () => Promise<Boolean>;
}

export interface ReviewAssignmentSubscription
  extends Promise<AsyncIterator<ReviewAssignment>>,
    Fragmentable {
  review_id: () => Promise<AsyncIterator<Int>>;
  competingInterests: () => Promise<AsyncIterator<String>>;
  dateAcknowledged: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateAssigned: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateCompleted: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateConfirmed: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateDue: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateNotified: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateRated: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateReminded: () => Promise<AsyncIterator<DateTimeOutput>>;
  dateResponseDue: () => Promise<AsyncIterator<DateTimeOutput>>;
  declined: () => Promise<AsyncIterator<Boolean>>;
  lastModified: () => Promise<AsyncIterator<DateTimeOutput>>;
  quality: () => Promise<AsyncIterator<Boolean>>;
  recommendation: () => Promise<AsyncIterator<Boolean>>;
  reminderWasAutomatic: () => Promise<AsyncIterator<Boolean>>;
  replaced: () => Promise<AsyncIterator<Boolean>>;
  reviewerFileId: () => Promise<AsyncIterator<Int>>;
  reviewerId: () => Promise<AsyncIterator<Int>>;
  reviewFormId: () => Promise<AsyncIterator<Int>>;
  reviewMethod: () => Promise<AsyncIterator<Boolean>>;
  reviewRoundId: () => Promise<AsyncIterator<Int>>;
  round: () => Promise<AsyncIterator<Boolean>>;
  stageId: () => Promise<AsyncIterator<Boolean>>;
  step: () => Promise<AsyncIterator<Boolean>>;
  submissionId: () => Promise<AsyncIterator<Int>>;
  unconsidered: () => Promise<AsyncIterator<Boolean>>;
}

export interface ReviewAssignmentNullablePromise
  extends Promise<ReviewAssignment | null>,
    Fragmentable {
  review_id: () => Promise<Int>;
  competingInterests: () => Promise<String>;
  dateAcknowledged: () => Promise<DateTimeOutput>;
  dateAssigned: () => Promise<DateTimeOutput>;
  dateCompleted: () => Promise<DateTimeOutput>;
  dateConfirmed: () => Promise<DateTimeOutput>;
  dateDue: () => Promise<DateTimeOutput>;
  dateNotified: () => Promise<DateTimeOutput>;
  dateRated: () => Promise<DateTimeOutput>;
  dateReminded: () => Promise<DateTimeOutput>;
  dateResponseDue: () => Promise<DateTimeOutput>;
  declined: () => Promise<Boolean>;
  lastModified: () => Promise<DateTimeOutput>;
  quality: () => Promise<Boolean>;
  recommendation: () => Promise<Boolean>;
  reminderWasAutomatic: () => Promise<Boolean>;
  replaced: () => Promise<Boolean>;
  reviewerFileId: () => Promise<Int>;
  reviewerId: () => Promise<Int>;
  reviewFormId: () => Promise<Int>;
  reviewMethod: () => Promise<Boolean>;
  reviewRoundId: () => Promise<Int>;
  round: () => Promise<Boolean>;
  stageId: () => Promise<Boolean>;
  step: () => Promise<Boolean>;
  submissionId: () => Promise<Int>;
  unconsidered: () => Promise<Boolean>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Author",
    embedded: false
  },
  {
    name: "ReviewAssignment",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
